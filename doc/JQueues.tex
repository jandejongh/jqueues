\documentclass[12pt]{book}

\usepackage{color}
\usepackage{listings}
\usepackage{array}
\usepackage{geometry}

\title{Discrete-Event Simulation\\
       of Queueing Systems in Java:\\
       The JSimulation and JQueues Libraries}
\author{Jan de Jongh}
\date{Release 5}

\lstset
{
  language=Java,
  basicstyle=\ttfamily,
  commentstyle=\textit,
  keywordstyle=\color{blue}\bfseries,
  tabsize=2,
  frame=single
}

\begin{document}

\maketitle

\chapter*{}

{\em This book is dedicated to Dick Epema and Graham Birtwistle.}

\tableofcontents

\chapter{Preface}

Queueing systems deal with the general notion of {\em waiting\ }
  for (the completion of) something.
They are ubiquitously and often annoyingly present in our everyday lives.
If there is anything we do most,
  it is probably {\em waiting\ } for something to
  happen (finally winning a non-trivial prize in the State Lottery
          after paying monthly tickets over the past thirty years),
  arrive (the breath-taking dress we ordered from that webshop
          against warnings in the seller's reputation blog),
  change (the reception of many severely bad hands in the poker game
          we just happened to ran into),
  stop (the constant flipping into red of traffic lights
        while we are just within breaking distance
        in our urban environment),
  or resume (the heater that regularly happens to have
             a mind of its own during
             winter months).

{\bf XXX}

\chapter{Introduction}

\chapter{Guided Tour}

\chapter{Events, Event Lists and Actions}

This chapter describes the event and event-list features
  that are available from the \lstinline{jsimulation} package.
Note that \lstinline{jsimulation} is a dependency of \lstinline{jqueues}.

\section{Creating the Event List and Events}

At the very heart of every simulation experiment
  in \lstinline{jqueues}
  is the so-called {\em event list}.
The event list obviously holds the events,
  keeps them ordered,
  and maintains a notion of "where we are" in a simulation run.
Together, an event list and the events it contains define
  the precise sequence of actions taken in a simulation.
The following code snipplet shows how to create an event list and
  schedule two (empty) events, one at $t_{1}=5.0$ and one at $t_{2}=10$,
  and print the resulting event list on \lstinline{System.out}:
\begin{lstlisting}
final SimEventList el = new DefaultSimEventList ();
final SimEvent e1 = new DefaultSimEvent (5.0);
final SimEvent e2 = new DefaultSimEvent (10.0);
el.add (e1);
el.add (e2);
el.print ();
\end{lstlisting}
In \lstinline{jsimulation},
  the event list is of type \lstinline{SimEventList};
  events are of type \lstinline{SimEvent},
  respectively.
Since both of them are Java {\em interfaces}, you need implementing classes
  to instantiate them: \lstinline{DefaultSimEventList} for an event list;
  \lstinline{DefaulSimEvent} for an event.
Typically,
  you instantiate a single event list for a simulation experiment,
  and numerous events.

The \lstinline{double} argument in the \lstinline{DefaultSimEvent} constructor
  (of which there are several)
  is the {\em schedule time\/} of the event on the event list.
Perhaps surprisingly,
  in \lstinline{jsimulation},
  the schedule time is actually held on the event,
 {\em not\/} on the event list.
Also, a \lstinline{SimEventList} is inheriting from \lstinline{SortedSet}
  from the Java Collections Framework.
These choices have the following consequences:
\begin{itemize}
  \item Each \lstinline{SimEvent} can be present {\em at most once\/} in a \lstinline{SimEventList}.
        You cannot reuse a single event instance (like a job creation and arrival event)
          by scheduling it multiple times on the event list.
        Instead, you must either use separate event instances, or reschedule the event
          the moment it leaves the event list.
  \item You cannot (more precisely, {\em should not\/}) modify the time on the event while it is
          scheduled on an event list.
  \item You always have access to the (intended) schedule time of the event, without having to
          refer to an event list (if the event is scheduled at all) or use a separate
          variable to keep and maintain that time.
  \item The events must be equipped with a {\em total ordering\/} (imposed by \lstinline{SortedSet})
          and distinct events should not be equal (imposed by us).
          This means that for each pair of (distinct) events scheduled on a \lstinline{SimEventList},
          one of them is always strictly larger than the other
          (in the ordering, they cannot be "equal").
\end{itemize}

The output of the code snipplet is something like\footnote{
We may have improved the layout in the meantime.}:
\begin{lstlisting}[basicstyle=\tiny]
SimEventList {X}.DefaultSimEventList@{Y}, class=DefaultSimEventList, time=-Infinity:
  t=5.0, name=No Name, object=null, action=null.
  t=10.0, name=No Name, object=null, action=null.
\end{lstlisting}
The output shows the name of the event list (as obtained from its \lstinline{toString} method)
  and the current time ($-\infty$) in the first row, and then the events in the list
  in the proper order.
By the way, we modified the output; the markers \lstinline|{X}| and \lstinline|{Y}|
  represents strings that most likely deviate on your system.

The output also shows the four properties of an event: its time, name, user object, and action.
These will be described in more detail in the next section.

\section{Event Properties and Event Constructors}

A \lstinline{SimEvent} has the following properties:
\begin{itemize}
\item Time:   The (intended) schedule time of the event (default $-\infty$).
\item Name:   The name of the event, which is only used for logging and output (default "No Name").
\item Object: A general-purpose object available for storing information associated with the event
              (\lstinline{jsimulation} nor \lstinline{jqueues} uses this field; its
              default value is \lstinline{null}).
\item Action: The action to take, a \lstinline{SimEventAction} (default \lstinline{null}),
                described in the next section.
\end{itemize}
Each property has corresponding getter and setter methods:

\begin{tabular}{|l|}
  \hline
  {\bf Properties of \lstinline|SimEvent|} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!double getTime ()! \\
  \lstinline[basicstyle=\footnotesize]!void setTime (double)! \\
  \hline
  \lstinline[basicstyle=\footnotesize]!String getName ()! \\
  \lstinline[basicstyle=\footnotesize]!void setName (String)! \\
  \hline
  \lstinline[basicstyle=\footnotesize]!T getObject ()! \\
  \lstinline[basicstyle=\footnotesize]!void setObject (T)! \\
  \hline
  \lstinline[basicstyle=\footnotesize]!SimEventAction getEventAction ()! \\
  \lstinline[basicstyle=\footnotesize]!void setEventAction (SimEventAction)! \\
  \hline
\end{tabular}

Note that \lstinline{T} refers to the so-called {\em generic-type argument\/}
  of \lstinline{SimEvent} (and also of \lstinline|DefaultSimEvent|).
The prototype is \lstinline|SimEvent<T>|, so \lstinline|T| can be any object type.
The use of generic types is explained in some more details in the "Advanced Topics" section,
  but for now \lstinline!T! can be simply read as a \lstinline{Object}.

The next section describes the actions in more detail, but we first provide a list
  of constructors for \lstinline{DefaultSimEvent}:

\begin{tabular}{|l|}
  \hline
  {\bf Constructors of \lstinline|DefaultSimEvent|} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!DefaultSimEvent (String, double, T, SimEventAction)! \\
  \lstinline[basicstyle=\footnotesize]!DefaultSimEvent (double, T, SimEventAction)! \\
  \lstinline[basicstyle=\footnotesize]!DefaultSimEvent (double, SimEventAction)! \\
  \lstinline[basicstyle=\footnotesize]!DefaultSimEvent (double)! \\
  \lstinline[basicstyle=\footnotesize]!DefaultSimEvent ()! \\
  \hline
\end{tabular}

Any non-listed property in a constructor will obtain its default value.

\section{Actions}

A \lstinline{SimEventAction} defined what needs to be done by the time an event
  is {\em executed\/} or {\em processed}.
In Java terms, a \lstinline{SimEventAction} is an interface with
  a single abstract method which is invoked when the event is processed.
Below we show the declaration of the interface:
\begin{lstlisting}[basicstyle=\tiny]
@FunctionalInterface
public interface SimEventAction<T>
{

  /** Invokes the action for supplied {@link SimEvent}.
   *
   * @param event The event.
   *
   * @throws IllegalArgumentException If <code>event</code> is <code>null</code>.
   * 
   */
  public void action (SimEvent<T> event);

}
\end{lstlisting}

There are several ways to create actions for events.
The first and most often used way in our own code is to use anonymous inner classes:
\begin{lstlisting}[basicstyle=\tiny]
final SimEventList el = new DefaultSimEventList ();
final SimEvent e =
  new DefaultSimEvent ("My First Real Event", 5.0, null, new SimEventAction ()
  {
    @Override
    public final void action (final SimEvent event)
    {
      System.out.println ("Event=" + event + ", time=" + event.getTime () + ".");
    }
    @Override
    public String toString ()
    {
      return "My First Action";
    }
  });
el.add (e);
el.print ();
el.run ();
el.print ();
\end{lstlisting}
Note that we are now using the full \lstinline{DefaultSimEvent} constructor,
  passing a name, and supplying a \lstinline{SimEventAction}
  as an anonymous inner class.
In the inner class, we define the \lstinline{action} method,
  and in the meantime override the \lstinline{toString} method
  (to be honest, this was merely to keep the generated text within bounds).
The generated output is:
\begin{lstlisting}[basicstyle=\tiny]
SimEventList {X}.DefaultSimEventList@{Y}, class=DefaultSimEventList, time=-Infinity:
  t=5.0, name=My First Real Event, object=null, action=My First Action.
Event=My First Real Event, time=5.0.
SimEventList {X}.DefaultSimEventList@{Y}, class=DefaultSimEventList, time=5.0:
  EMPTY!
\end{lstlisting}
Clearly, as expected!
However, rote that after "running" the event list, it turns out to be empty,
  and its time is now $t=5.0$, the schedule time of our event.
This is as intended, and will be explained in the next section.
But first we look at an alternative way of attaching
  actions to events:
\begin{lstlisting}[basicstyle=\tiny]
final SimEventList el = new DefaultSimEventList ()
{
  @Override
  public final String toString ()
  {
    return "My Renamed Event List";
  } 
};
final SimEventAction action = new SimEventAction ()
{
  @Override
  public final void action (final SimEvent event)
  {
      System.out.println ("Event=" + event + ", time=" + event.getTime () + ".");
  }
  @Override
  public final String toString ()
  {
    return "A Shared Action";
  }
};
for (int i = 1; i <= 10; i++)
{
  final SimEvent e = new DefaultSimEvent ("Our Event", (double) i, null, action);
  el.add (e);
}
el.print ();
el.run ();
el.print ();
\end{lstlisting}
In this example, we created a single action object
  (again using an anonymous inner class),
  and reuse it among ten distinct events we schedule
  (we cannot reuse those).
We also took the opportunity give our
  event list a friendlier name by overriding its \lstinline{toString} method.
The output is as follows:
\begin{lstlisting}[basicstyle=\tiny]
SimEventList My Renamed Event List, class=, time=-Infinity:
  t=1.0, name=Our Event, object=null, action=A Shared Action.
  t=2.0, name=Our Event, object=null, action=A Shared Action.
  t=3.0, name=Our Event, object=null, action=A Shared Action.
  t=4.0, name=Our Event, object=null, action=A Shared Action.
  t=5.0, name=Our Event, object=null, action=A Shared Action.
  t=6.0, name=Our Event, object=null, action=A Shared Action.
  t=7.0, name=Our Event, object=null, action=A Shared Action.
  t=8.0, name=Our Event, object=null, action=A Shared Action.
  t=9.0, name=Our Event, object=null, action=A Shared Action.
  t=10.0, name=Our Event, object=null, action=A Shared Action.
Event=Our Event, time=1.0.
Event=Our Event, time=2.0.
Event=Our Event, time=3.0.
Event=Our Event, time=4.0.
Event=Our Event, time=5.0.
Event=Our Event, time=6.0.
Event=Our Event, time=7.0.
Event=Our Event, time=8.0.
Event=Our Event, time=9.0.
Event=Our Event, time=10.0.
SimEventList My Renamed Event List, class=, time=10.0:
  EMPTY!
\end{lstlisting}
Again note that the time on the event list after running it
  is the time of the last event we scheduled on it.
In the output, funny enough, the \lstinline{class} of the event list
  is now reported as empty.
This is because we used an anonymous class to construct it!

So, there are different ways of attaching a \lstinline{SimEventAction}
  to a \lstinline{DefaultSimEvent}.
The abundant use of anonymous inner classes as shown here
  is certainly not to everyone's taste,
  but it results in relatively compact code
  (even more through the use of lambda expressions, see {\bf XXX}).

\section{Processing the Event List}

Once the events of your liking are scheduled on the event list,
  you can start the simulation by {\em processing\/} or {\em running\/}
  the event lists.
Processing the event list will cause the event list to
  equentially invoke the actions attached to the events
  in increasing-time order.
There are several ways to process a \lstinline{SimEventList}:
\begin{itemize}
  \item You can process the event list until it is empty with the \lstinline{run} method.
  \item You can process the event list until some specified (simulation) time with the
          \lstinline{runUtil} method.
  \item You can {\em single-step\/} through the event list with the
          \lstinline{runSingleStep} method.
\end{itemize}
You can check whether an event list is being processed through its \lstinline{isRunning}
  method.

While processing, the event list maintains a {\em clock}
  holding the (simulation) time of the current event.
You can get the time from the event list through \lstinline{getTime} nethod,
  although you can obtain it more easily from the event itself.
You can insert new events while it is being processed,
  {\em but these events must not be in the past}.
Once the event list detects insertion of events in the past,
  it will throw and exception.

Note that processing the event list
  is thread-safe in the sense that all methods involved
  need to obtain a {\em lock} before being able to process the list.
Trying to process an event list that is already being processed
  from another thread,
  or from the thread that currently processes the list,
  will lead to an exception.
Note that currently there is no safe, atomic, way
  to process an event list on the condition that is
  is not being processed already.
Though you can check with \lstinline{isRunning}
  whether the list is being processed or not,
  the answer from this method has zero validity lifetime.

The example below shows how to schedule new events
  from event actions; it also shows what happens if you schedule
  events in the past.
\begin{lstlisting}[basicstyle=\tiny]
final SimEventList el = new DefaultSimEventList ()
{
  @Override
  public final String toString ()
  {
    return "The Event List";
  } 
};

final SimEventAction schedulingAction = new SimEventAction ()
{
  private int counter = 0;
  @Override
  public final void action (final SimEvent event)
  {
      System.out.println ("Event=" + event + ", time=" + event.getTime () + ".");
      counter++;
      if (counter < 10)
        // Schedule 1 second from now.
        // Use utility method on SimEventList.
        el.schedule (event.getTime () + 1, this);
      else if (counter == 10)
      {
        // Schedule now.
        el.schedule (event.getTime (), this);
        System.out.println ("Scheduled event now.");
      }
      else
      {
        // Schedule 1 second in the past -> throws exception.
        el.schedule (event.getTime () - 1, this);
        // Never reached.
        System.out.println ("Scheduled event in the past.");
      }
  }
  @Override
  public final String toString ()
  {
    return "Scheduling Action";
  }
};
    
el.schedule (0, schedulingAction);
el.print ();
el.run ();
el.print ();
\end{lstlisting}
The code begins to look familiar.
First, we create the event list, then a single action.
The action is a bit more complicated than before;
  it has an internal \lstinline{counter} in the anynoumous class.
Using the counter, it reschedules itself ten times,
  the first nine times one second in the future,
  the tenth time at exactly the same time.
As mentioned before, this is perfectly legal
  (and, in fact, often used in our own code).
The final attempt to reschedule the action results in an
  exception, because the event is scheduled in the past.
Note that the example also showcases a utility method
  in \lstinline{SimEventList}, viz., \lstinline{schedule (double, SimEventAction)},
  which directly schedules the action on the event list at given time,
  creating a new \lstinline{SimEvent} on the fly.
In a later section we will look in more detail at more utility methods
  on event lists.

The output of the example is shown below\footnote{
  For improved reading, we have left out the full stack-trace of the exception,
  and rearranged the mixed outputs from \lstinline{System.out} and \lstinline{System.err}.
  We will do that without notice in the sequel.
}.
\begin{lstlisting}[basicstyle=\tiny]
SimEventList The Event List, class=, time=-Infinity:
  t=0.0, name=No Name, object=null, action=Scheduling Action.
Event=No Name, time=0.0.
Event=No Name, time=1.0.
Event=No Name, time=2.0.
Event=No Name, time=3.0.
Event=No Name, time=4.0.
Event=No Name, time=5.0.
Event=No Name, time=6.0.
Event=No Name, time=7.0.
Event=No Name, time=8.0.
Event=No Name, time=9.0.
Scheduled event now.
Event=No Name, time=9.0.
Exception in thread "main" java.lang.IllegalArgumentException:
Schedule time is in the past: 8.0 < 9.0!
\end{lstlisting}
Note that in this particular case,
  the exception thrown actually comes with an
  instructive message as to what caused it
  (you tried to schedule something on the event list at $t=8.0$,
   whereas the current time is beyond that, $t=9.0$).
However, in all honesty,
  such messages are not present
  for the majority of exceptions thrown
  as a result of incorrect arguments from user code.
We are currently working on improving this.

The output also shows the expected result from the first \lstinline{el.print} statement:
Only a single event is scheduled!
The others are created and scheduled while the event list is being processed.
It is important to realize that the contents of a \lstinline{SimEventList}
  can always change, as long as these are changes {\em now or in the future}.
By the way, the second invocation of \lstinline{el.print} does not stand a chance;
  it is unreachable because of the exception thrown in \lstinline{el.run}.

\section{Utility Methods for Scheduling Events}

A \lstinline{SimEventList} supports various methods for
  directly scheduling events and actions
  without the need to generate both
  the \lstinline{SimEvent} {\em and\/} the \lstinline{SimEventAction}.
In most cases, the availability of one of the object suffices.
Below we show the most common utility methods for scheduling on a \lstinline{SimEventList}.

\begin{tabular}{|l|}
  \hline
  {\bf Utility methods for scheduling} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void schedule (E)! \\
    Schedules the event at its own time.\\
  \hline
  \lstinline[basicstyle=\footnotesize]!void schedule (double, E)! \\
    Schedules the event at given time.\\
  \hline
  \lstinline[basicstyle=\footnotesize]!reschedule (double, E)! \\
    Reschedules (if present, else schedules) the event at given new time.\\
  \hline
  \lstinline[basicstyle=\footnotesize]!E schedule (double, SimEventAction, String)! \\
    Schedules the action at given time with given event name.\\
  \hline
  \lstinline[basicstyle=\footnotesize]!void scheduleNow (E)! \\
    Schedules the event now.\\
  \hline
  \lstinline[basicstyle=\footnotesize]!E schedule (double, SimEventAction)! \\
    Schedules the action at given time with default event name.\\
  \hline
  \lstinline[basicstyle=\footnotesize]!E scheduleNow (SimEventAction, String)! \\
    Schedules the action now with given event name.\\
  \hline
  \lstinline[basicstyle=\footnotesize]!E scheduleNow (SimEventAction)! \\
    Schedules the action now with default event name.\\
  \hline
\end{tabular}

Note that \lstinline{E} refers to the so-called {\em generic-type argument\/}
  of \lstinline{SimEventList}.
The prototype is \lstinline!SimEventList<E extends SimEvent>!.
The use of generic types is explained in some more details in the "Advanced Topics" section,
  but for now \lstinline!E! can be simply read as a \lstinline{SimEvent}.

For any of the utilty methods that take a \lstinline{SimEventAction}
  as argument, a new \lstinline{SimEvent} is created on the fly,
  and returned from the method.
Upon return from these methods,
  the newly created event has already been scheduled,
  and you {\em really\/} should not schedule it again.

You may wonder how to {\em remove\/} events and actions from the event list.
Well, since \lstinline{SimEventList} implements the \lstinline{Set} interface for
  \lstinline{SimEvent} members, removing an event \lstinline{e}
  from an event list \lstinline{el} is as simple as
  \lstinline{el.remove (e)}.
Currently, there is no support to remove an action from an event list.
Because actions can be reused, it would require iterating over
  all scheduled events,
  and remove all events with the given action.
It is not hard to implement at all, we just did not do it\footnote{
This code fragment has not been tested.}:
\begin{lstlisting}[basicstyle=\tiny]
public static void removeAction
(final SimEventList eventList, final SimAction action)
{
  if (eventList != null)
  {
    final Iterator it = eventList.iterator;
    while (it.hasNext ())
      if (it.next ().getEventAction () == action)
        it.remove ();
  }
}
\end{lstlisting}
The code fragment silently assumes
  the absence of \lstinline{null} events
  in the event list,
  which is indeed guaranteed,
  and works perfectly for \lstinline{null} actions.
Note the somewhat unexpected method name on \lstinline{SimEvent}
  to get its action, viz., \lstinline{getEventAction}.
This name was chosen in order to avoid potential name clashes.
At the risk of sounding pedantic,
  the explicit use of the iterator
  looks old-fashioned,
  yet allows for
  the safe removal of elements
  from a collection in a loop
  (contrary to a much fancier \lstinline{for} construction).

We conclude with an overview of
  non-scheduling related utility methods
  of \lstinline{SimEventList}:

\begin{tabular}{|l|l|}
  \hline
  {\bf Method} & {\bf Description} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void print ()! & Prints the event list to \lstinline!System.out!. \\
  \lstinline[basicstyle=\footnotesize]!void print (PrintStream)! & Prints the event list to the stream. \\
  \hline
\end{tabular}

\section{Simultaneous Events}

While reading through the previous sections,
  you may have wondered
  what would happen
  if two events are scheduled
  on exactly the same time.
Well, why not just give it a try?
First, we create an action class with an index number as argument;
  when invoked, the action merely prints its index number
  to \lstinline{System.out}:
\begin{lstlisting}[basicstyle=\tiny]
private static class IndexedSimEventAction
implements SimEventAction
{
  
  final int index;
  
  public IndexedSimEventAction (final int index)
  {
    this.index = index;
  }
  
  @Override
  public void action (SimEvent event)
  {
    System.out.println ("Hello, I am action number " + this.index + "!");
  }

  @Override
  public String toString ()
  {
    return "Action " + index;
  }
  
}
\end{lstlisting}
So, let us schedule some of these at $t=0$
  in order of increasing index:
\begin{lstlisting}[basicstyle=\tiny]
final SimEventList el = new DefaultSimEventList ();
for (int i = 1; i <= 10; i++)
  el.schedule (0, new IndexedSimEventAction (i), "Event " + i);
el.print ();
el.run ();
\end{lstlisting}
The potential result of this code may be a bit surprising\footnote{
The probablity of you seeing the same result is $1/(10!)$,
  which equals the probability
  of you being {\em not\/} surprised at all about your own output.}:
\begin{lstlisting}[basicstyle=\tiny]
SimEventList {X}@{Y}, class=DefaultSimEventList, time=-Infinity:
  t=0.0, name=Event 3, object=null, action=Action 3.
  t=0.0, name=Event 8, object=null, action=Action 8.
  t=0.0, name=Event 9, object=null, action=Action 9.
  t=0.0, name=Event 5, object=null, action=Action 5.
  t=0.0, name=Event 1, object=null, action=Action 1.
  t=0.0, name=Event 4, object=null, action=Action 4.
  t=0.0, name=Event 7, object=null, action=Action 7.
  t=0.0, name=Event 2, object=null, action=Action 2.
  t=0.0, name=Event 6, object=null, action=Action 6.
  t=0.0, name=Event 10, object=null, action=Action 10.
Hello, I am action number 3!
Hello, I am action number 8!
Hello, I am action number 9!
Hello, I am action number 5!
Hello, I am action number 1!
Hello, I am action number 4!
Hello, I am action number 7!
Hello, I am action number 2!
Hello, I am action number 6!
Hello, I am action number 10!
\end{lstlisting}
Well, it looks like all our scheduled events were indeed processed,
  {\em but not in the order we inserted them into the list!}
It was even clear {\em before\/} processing the event list that there
  was something "wrong" with the sequence of events.
Why?
Well, because we explictly instructed the \lstinline{SimEventList}
  {\em not\/} to do process simultaneous events in so-called
  {\em insertion order},
  but instead to break ties {\em at random\/} for
  simultaneously scheduled events.
The exact reasoning for doing this is a bit involved,
  and deferred until the "Advanced Topics" section,
  but for now it is important to realize that
  a \lstinline{DefaultSimEventList}
\begin{itemize}
  \item processes its scheduled events in random order
        should they have equal schedule times;
  \item will {\em never\/} preempt or interrupt the current event it is processing
        in favor of another event that is scheduled at the same time from within the
        action of the current event.
\end{itemize}

Since there is absolutely nothing wrong with maintaining insertion order,
  you can switch to a different event-list implementation, viz., \lstinline{DefaultEventList_IOEL}:
\begin{lstlisting}[basicstyle=\tiny]
final SimEventList el = new DefaultSimEventList_IOEL ();
for (int i = 1; i <= 10; i++)
  el.schedule (0, new IndexedSimEventAction (i), "Event " + i);
el.print ();
el.run ();
\end{lstlisting}
Now the output looks mores structured:
\begin{lstlisting}[basicstyle=\tiny]
SimEventList {X}.DefaultSimEventList_IOEL@{Y}, class=DefaultSimEventList_IOEL,
    time=-Infinity:
  t=0.0, name=Event 1, object=null, action=Action 1.
  t=0.0, name=Event 2, object=null, action=Action 2.
  t=0.0, name=Event 3, object=null, action=Action 3.
  t=0.0, name=Event 4, object=null, action=Action 4.
  t=0.0, name=Event 5, object=null, action=Action 5.
  t=0.0, name=Event 6, object=null, action=Action 6.
  t=0.0, name=Event 7, object=null, action=Action 7.
  t=0.0, name=Event 8, object=null, action=Action 8.
  t=0.0, name=Event 9, object=null, action=Action 9.
  t=0.0, name=Event 10, object=null, action=Action 10.
Hello, I am action number 1!
Hello, I am action number 2!
Hello, I am action number 3!
Hello, I am action number 4!
Hello, I am action number 5!
Hello, I am action number 6!
Hello, I am action number 7!
Hello, I am action number 8!
Hello, I am action number 9!
Hello, I am action number 10!
\end{lstlisting}
Just in case you are curious: we use the abbreviations ROEL for Random-Order Event List
  and IOEL for Insertion-Order Event List.
The \lstinline|DefaultSimEventList| is obviously a ROEL; actually it
  subclasses \lstinline|DefaultSimEventList_ROEL| without changes,
  hence you can also use \lstinline|SimEventList_ROEL|
  as your event-list implementation
  (perhaps making more explicit the nature of the event list):
\begin{lstlisting}[basicstyle=\tiny]
// Be very careful: this event-list does not respect insertion
// order for simultaneous events!
// ROEL = Random-Order Event List.
final SimEventList el = new DefaultSimEventList_ROEL ();
\end{lstlisting}

We want to stress that just because our default event-list implementation is
  a ROEL, it is by no means because ROEL "is just better" than IOEL,
  or the software in \lstinline|jsimulation| and/or \lstinline|jqueues|
  "works better" or even "works only" with a ROEL.
Far from it, the current implementations will probably work slightly faster
  with an IOEL; maintaining insertion order is likely to be faster
  that drawing random number upon each insertion.
So, by all means, use the IOEL implementation if you want to as a
  replacement to the default ROEL.

\section{Resetting an Event List}

By resetting an event list,
  through \lstinline|reset|,
  we remove all the events it contains,
  and set the time to $t=-\infty$,
  or to a user-specified time through
  \lstinline|reset (double)|.
Resetting an event list is typically done before repeating a simulation experiment,
  for instance with a different seed value for random-number generation.

Despite the simplicitly of the concept, we cannot stress enough the importance and consequences of
  resetting an event list.
Although not mandated by \lstinline|jsimulation|,
  the general convention we follow is that an even-list reset puts
  the event list itself, but also all "entities" (like queues) that use it
  {\em in a well-known, default, often "empty", state.}
Partially to that purpose,
  an event list informs its so-called {\em reset listeners\/} when it is reset.
The concept of listeners is described in the next section.

For reasons that will become clear later,
  in particular when discussing obtaining statistics on queueing systems in {\bf XXX},
  it is {\em highly recommended\/} to always reset the event list to a {\em finite\/}
  time, even before running it for the first time.

One may wonder why we chose $-\infty$ as the default new time upon a reset,
  instead of a finite value (zero comes to mind here...).
Well, first, we wanted a "fresh" event list to accept all events scheduled at
  {\em arbitrary\/} time.
(Recall that even without running an event list,
  it will throw an exception if events are scheduled "in the past".)
Second, we wanted to avoid the ubiquitous "a simulation starts at $t=0$" assumption,
  at least in our own code.
For instance,
  it would be very hard to debug the case in which a statistics-gathering object
  (e.g., measuring the average number of jobs in a queue)
  silently assumes that all simulations start at $t=0$,
  and the user decides to run a simulation at (for whatever reason) $t=+100$.

On the other hand,
  having to remember to pass a finite time upon every reset is, admittedly, far from ideal.
The \lstinline|setDefaultResetTime (double)| therefore allow for changing the
  default event-list start time used by \lstinline|reset ()|.
Note though, that this still requires explicit resets of the event list,
  even before using it for the first time.
We are still seeking to improve the reset semantics,
  in particular related to the new time on the event list
  and its effect on statistics gathering.

{\bf ADD AN EXAMPLE OR TWO HERE!}

\section{Listening to an Event List}

You can listen to changes to a \lstinline{SimEventList} by registering
  a {\em listener\/} of type \lstinline{SimEventListListener} to it.
At the present time,
  there is only support for notifications
  for an event list reset,
  and for event-list processing
  so there is not general "event list changed" notfication.

A listener gets notifications for:
\begin{itemize}
\item A {\em reset\/} of the event list.
      This notification is always sent while the list is {\em not\/} begin processed.
      In fact, if you are only interested in receiving
      reset notifications, you can use a \lstinline|SimEventListResetListener| instead
      of (the full) \lstinline|SimEventListListener|.
\item An {\em update\/} of the event list.
      An update is defined as a {\em strictly positive jump in time during processing.}
\item An {\em empty\/}  event list during processing (this effectively ends processing the event list).
\item A {\em next event\/} while processing the event list.
      These notifications, however, are only sent to listeners that implement
      \lstinline|SimEventListListener.Fine|.
\end{itemize}

The following table summarizes the listener-related methods on a \lstinline-SimEventList-.

\begin{tabular}{|l|l|}
  \hline
  {\bf Method} & {\bf Description} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void addListener (SimEventListResetListener)!
    & Adds a listener. \\
  \lstinline[basicstyle=\footnotesize]!void removeListener (SimEventListResetListener)!
    & Removes a listener. \\
  \hline
\end{tabular}

The table below list the various notification methods on a listener
  per listener type; the types are shown in increasing richness.

\begin{tabular}{|l|l|}
  \hline
  {\bf Method} & {\bf Description} \\
  \hline
  \multicolumn{2}{|c|}{\bf \lstinline[basicstyle=\small]{SimEventListResetListener}} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void notifyEventListReset (SimEventList)!
    & Reset of given event list. \\
  \hline
  \multicolumn{2}{|c|}{\bf \lstinline[basicstyle=\small]{SimEventListListener}} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void notifyEventListUpdate (SimEventList, double)!
    & Event list update; {\em new\/} time. \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void notifyEventListEmpty (SimEventList, double)!
    & Event list empty at given time. \\
  \hline
  \multicolumn{2}{|c|}{\bf \lstinline[basicstyle=\small]{SimEventListListener.Fine}} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void notifyNextEvent (SimEventList, double)!
    & Process next event; {\em old\/} time. \\
  \hline
\end{tabular}

\section{Advanced Topics}

In this section we take a closer look at some more advanced topics
  \lstinline-jsimulation-.
The sections can be skipped at first reading.

\subsection{Using Generic-Type Arguments}

\begin{tabular}{|l|l|l|}
  \hline
  {\bf Interface} & {\bf Type} & Description \\
  \hline
  \lstinline|SimEvent<T>| & \lstinline|T| & The type of user object. \\
  \hline
  \lstinline|SimEventList<E extends SimEvent>| & \lstinline|E| & The type of events. \\
  \hline
  \lstinline|SimEventAction<T>| & \lstinline|T| & The type of user object. \\
  \hline
\end{tabular}

The (partial) implementations in \lstinline|jsimulation| follow the same convention
  as the interface they belong to:

\begin{tabular}{|l|}
  \hline
  {\bf Class} \\
  \hline
  \lstinline|DefaultSimEvent<T>| \\
  \hline
  \lstinline|AbstractSimEventList<E extends SimEvent>| \\
  \hline
  \lstinline|DefaultSimEventList_IOEL<E extends SimEvent>| \\
  \hline
  \lstinline|DefaultSimEventList_ROEL<E extends SimEvent>| \\
  \hline
  \lstinline|DefaultSimEventList<E extends SimEvent>| \\
  \hline
\end{tabular}

\subsection{Event Factories}

An {\em event factory\/} has a sole purpose: generating new event instances.
The use of factories is very common in Java,
  expecially if one needs to create a "default"
  instance for a given interface,
  in our case for \lstinline-SimEvent-.

The \lstinline|SimEventFactory| interface is as follows:

\begin{lstlisting}[basicstyle=\footnotesize]
@FunctionalInterface
public interface SimEventFactory<E extends SimEvent>
{
  
  E newInstance
    (String name, double time, SimEventAction eventAction);

}
\end{lstlisting}

The generic type argument \lstinline|E| is the (base) type
  of the generated \lstinline|SimEvent|s.
The argument list for \lstinline|newInstance| allows
  for setting all \lstinline|SimEvent| properties except the user object
  (because we believe it is rarely of use).

One particular use for this is to set the event factory
  on an arbitary \lstinline|SimEventList|
  through its \lstinline|setSimEventFactory| method.
This is a safe way of using an interface (or event multiple ones)
  as type argument to \lstinline|SimEventList|:

\begin{lstlisting}[basicstyle=\footnotesize]
interface MySimEvent
extends SimEvent
{
  BigInteger getSeqNumber ();
}
  
static class DefaultMySimEvent
extends DefaultSimEvent
implements MySimEvent
{

  private static BigInteger
    NEXT_SEQUENCE_NUMBER = BigInteger.ZERO;
  
  private final BigInteger seqNumber;
  
  @Override
  public final BigInteger getSeqNumber ()
  {
    return this.seqNumber;
  }

  public DefaultMySimEvent
    (final String name,
     final double time,
     final SimEventAction action)
  {
    super (name, time, null, action);
    this.seqNumber = NEXT_SEQUENCE_NUMBER;
    NEXT_SEQUENCE_NUMBER =
      NEXT_SEQUENCE_NUMBER.add (BigInteger.ONE);
  }
  
}
  
public static void main (final String[] args)
{
  final SimEventList<MySimEvent> el =
    new DefaultSimEventList (MySimEvent.class);
  el.add (new DefaultMySimEvent
    ("MySimEvent instance", 5.0, null));
  el.print ();
}
\end{lstlisting}

In the code fragment, we extended the basic \lstinline{SimEvent}
  interface with a method to
  maintain a global instance counter
  of type \lstinline|BigInteger|
  (ignoring the total lack of usefulness),
  and created a default implementation for it
  in \lstinline|DefaultMySimEvent|.
Subsequently, we created an event list,
  using the generic-type argument and
  the \lstinline|class| argument in the constructor
  to make sure that the \lstinline-DefaultSimEventList-
  only accepts \lstinline-MyEventType- as
  events.
Note that we use the {\em interface\/} here,
  not the {\em default implementation}.
The program runs fine and prints the event
  scheduled on the event list.

However, if we try to schedule an action
  (\lstinline|null| in this case):
\begin{lstlisting}[basicstyle=\footnotesize]
  el.schedule (10.0, (SimEventAction) null);
\end{lstlisting}
we are treated with an exception:
\begin{lstlisting}[basicstyle=\footnotesize]
...IllegalStateException: Cannot instantiate MySimEvent!
\end{lstlisting}
It is more or less immediately clear what the problem is:
  the event list has to generate a \lstinline|SimEvent|
  in order to schedule the action,
  but it tries to instantiate \lstinline|MySimEvent|,
  which is an {\em interface\/}.
(By the way, it also assumes that the event class
  supports a parameterless constructor!)

We need to tell the event list how to create the events
  for the various utility methods,
  and we do that by creating and registering a
  \lstinline|SimEventFactory| for \lstinline|MySimEvent|\footnote{
Using a {\em lambda expression\/} this time, see {\bf XXX}.}:
\begin{lstlisting}[basicstyle=\footnotesize]
final SimEventList<MySimEvent> el =
  new DefaultSimEventList (MySimEvent.class);
el.setSimEventFactory
(
  (final String name,
   final double time,
   final SimEventAction eventAction)
    -> new DefaultMySimEvent (name, time, eventAction)
);
el.add (new DefaultMySimEvent
  ("MySimEvent instance", 5.0, null));
el.schedule (10.0, (SimEventAction) null);
el.print ();
\end{lstlisting}
Now we are out of trouble:
\begin{lstlisting}[basicstyle=\footnotesize]
...
t=5.0, name=MySimEvent instance, object=null, action=null.
t=10.0, name=null, object=null, action=null.
\end{lstlisting}
  
This section and the previous one on generic-type
  arguments hopefully showed the maturity of
  support the generic and runtime type arguments.
However,
  we do not recommend their use unless
  for very specific use cases
  that require extending the
  \lstinline|SimEvent| and/or \lstinline|SimEventList|
  interfaces.
The problem is that by restricting the
  allowable compile-time and runtime \lstinline|SimEvent|
  types, the generated objects
  become unusable for libraries
  using "bare" \lstinline|SimEvent|s.
For instance,
  the \lstinline|jqueues| library
  will not work with event-lists
  not supporting "plain" \lstinline|SimEvent|s.

\subsection{Simultaneous Events: Random-Order and Insertion-Order Event Lists}

In previous sections in this book,
  we explained that event-list implementations,
  at least the {\em non-preemptive\/} types,
  come in two natural variants:
  the ROEL processes simultaneous events in random order,
  and the IOEL does that in insertion order.
We also declared that the default implementation is a
  ROEL, and that you can easily switch to an IOEL,
  possibly even gaining some performance.
This section is dedicated to motivating the use of,
  or even the consideration of ROEL as an event list implementation,
  let alone making it the default!
It does not introduce any new software.
We already want to stress that ROEL is by no means
  "better" than IOEL from a user point of view.
We do not intend to avocate ROEL over IOEL!

The distinction between ROEL and IOEL is all about {\em simultaneous\/}
  events, and we look at this phenomena from three different viewpoint:
\begin{itemize}
\item The {\em physical\/} viewpoint: In physics, we are rarely concerned with occurence of
        simultaneous events, because physical models (to our knowledge) rarely
        exhibit a strong behavioral dependence on "things happening at the same time".
\item The {\em mathematical\/} viewpoint: In mathematical models, we {\em are\/}
        nearly always dealing with teh possiblity of "things being equal".
      For instance, it is "undone" two specify an function on two real variables
        (say, a "maximum indicator") without exactly specifying the result
        for equal inputs.
      However, in applications of probability theory, like queueing theory,
        we often deal with continuous distrubutions and
        the probability of simulteneous events is often zero.
      Although simulteneous events still require attention,
        one can usually get away with noting that
        "ties are broken at random (with equal probabilities)".
      Almost always, this solution approach is preferred over trying
        to impose an additional ordering on the events, as in
        "Jobs A and B both arrived at $t=0$, but job A was first."
\item The {\em software-engineering\/} viewpoint: In software-engineering,
        we are not that used to simultaneous events.
      Sure, there are cases of {\em concurrency\/}
        but the problems that arise are usually fixed by
        imposing some {\em order\/} into which statements,
        programs, expressions, etc. are to be processed.
      As a result, software engineering is very much concerned with
        "doing the right thing given a strict order of input".
      A prime example of this are Finite-State Machines supporting
        state transitions upon external events.
      Rarely, if ever, does this take into account the possiblity
        of simultaneous events.
\end{itemize}
Needless to say, our argument is that {\em the occurence of simulatenous events
  is very natural in mathematics, yet the concept of "insertion order"
  is purely relevant to software-engineering.}
In other words, there is no equivalence in this context for "insertion order"
  in mathematics, nor is there is physics.

The reasons for choosing a Random-Order Event List are
  primarily motivated by its use in \lstinline|jqueues|:
\begin{itemize}
  \item We do not want to {\em specify\/} queueing systems with the notion of
          insertion order, and we probably cannot.
        Such a specification would be overly complicated, and, as mentioned before,
          in the mathematical context we rather break ties at random.
  \item We do not want to {\em imply\/} to users the conservation of insertion order
          in the implementations.
  \item We do not want to {\em rely\/} on insertion order of events in our tests.
\end{itemize}

Admittedly, for simple queueing systems like FCFS,
  it seems simple enough to maintain the order of arrival of jobs
  in the output process.
But as soon as queueing systems become more complicated,
  especially if multiple queues are involved or feedback,
  the specification becomes just unnecessarily difficult.
To give an example: Suppose we have a feedback FCFS queue with
  feedback probability $1/4$ and two jobs arriving at $t=0$;
  jobs A and B having required service times (for each visit)
  of zero and unity, respectively.
Suppose with an insertion-order event list, job A's first
  arrival is before job B's.
So, trusting the conservation of insertion order,
  the queue starts processing job A,
  which is fed back to the queue's input immediately
  with probability $1/4$.
If so, we are in trouble because we now have to specify
  whether to first serve job A reappearing at the input
  or job B.
Of course we can find a solution by indeed specifying that
  a job that is fed back is always inserted {\em after\/} jobs
  already there, but the real problem is that
  {\em we have to specify all cases of simultaneus events through
  insertion-order arguments.}
And this is just a simple example.

\subsection{Event Comparators}

In order to obtain the required  total order on the \lstinline|SimEvent|s 
  in a \lstinline|SimEventList|,
  the latter uses a \lstinline|Comparator|,
  which by default is an instance of \lstinline|DefaultSimEventComparator|,
  both for ROEL (the default) and IOEL event lists.
Its core implementation is
\begin{lstlisting}[basicstyle=\footnotesize]
@Override
public int compare (E e1, E e2)
{
  int c = Double.compare (e1.getTime (), e2.getTime ());
  if (c == 0)
  {
    c = e1.getSimEventListDeconflictValue ()
        .compareTo
        (e2.getSimEventListDeconflictValue ());
  }
  if ((e1 == e2 && c != 0)
      || (e1 != e2 && c == 0))
    throw new RuntimeException
     ("Error attempting to order events.");
  return c;
}
\end{lstlisting}
Not surprisingly,
  the comparator uses the time property on the events to make a first
  comparison.
In case of a tie,
  it uses the so-called {\em deconflict value\/} on the events,
  throwing an exception if this still yields a tie.
What is intteresting to note is that the deconflict value
  on an event is generated when an event is {\em added\/} to
  an event list by overriding the \lstinline|add| and \lstinline|addAll|
  methods from the super class (i.c., \lstinline|TreeSet|),
  e.g., in case of ROEL:
\begin{lstlisting}[basicstyle=\footnotesize]
@Override
public final boolean add (final E e)
{
  if (e == null)
    throw new NullPointerException
      ("Attempt to add null event to event list!");
  if (! contains (e))
  {
    e.setSimEventListDeconflictValue
      (this.rngDeconflict_ROEL.nextLong ());
    return super.add (e);
  }
  return false;
}
\end{lstlisting}
In ROEL, the deconflict value is,
  as expected drawn from a random-number generator (RNG)
  \lstinline|rngDeconflict_ROEL|.
Using this approach has the major advantage that
  even though events with equal times will
  be ordered at random,
  their ordering remains fixed as long as they are
  in the event list.
So, the random ordering in ROEL is {\em not\/} implemented
  by drawing from a RNG the moment it is needed from
  the event list (which would, actually, be substantially more difficult),
  but it is already fixed upon insertion.
This, for instance, has the nice feature that
  consecutive iterators over the (same) event set will always
  return the events in the same order.
By the way, you can set an alternative \lstinline|Comparator|
  by using one of \lstinline|AbstractSimEventList| constructors.
You cannot change it on the default implementations.

\subsection{Action is a Functional Interface}

Because a \lstinline|SimEventAction| is an interface with
  exactly one abstract method,
  it can be used in so-called {\em lambda expressions\/} in Java 8.
So, instead of

\begin{lstlisting}[basicstyle=\small]
final SimEventAction action = new SimEventAction ()
{
  @Override
  public final void action (final SimEvent event)
  {
    // Do something with event...
  }
};
\end{lstlisting}

you can also write:

\begin{lstlisting}[basicstyle=\small]
final SimEventAction action =
  (SimEventAction) (final SimEvent event) ->
  {
    // Do something with event...
  };
\end{lstlisting}

or even make it a one-liner.

The \lstinline{SimEventAction} interface has been marked a \lstinline|@FunctionalInterface|.

\section{Timers}

The abstract \lstinline|AbstractSimTimer| class is a small
  utility class for scheduling a timer on a \lstinline-SimEventList-.
In view of the classes and methods described before it
  is not all that useful, but it has been kept
  in the library for support of legacy code.
An \lstinline|AbstractSimTimer| features a
  \lstinline|schedule (double, SimEventList)| method
  that schedules an appropriate event after a delay
  (the \lstinline|double| argument).
When the event is processed,
  the (abstract) method \lstinline-expireAction- is invoked,
  which needs to be defined in a subclass.
Also, a pending timer can be (safely) cancelled
  through its \lstinline-cancel- method.

Below is a small, naive example of its use:
\begin{lstlisting}[basicstyle=\small]
private static class MyTimer
extends AbstractSimTimer
{
  @Override
  public final void expireAction
  (final double time)
  {
    System.out.println ("t=" + time + ": Timer expired!");
  }
}
  
public static void main (final String[] args)
{
  final SimEventList el = new DefaultSimEventList ();
  final MyTimer myTimer = new MyTimer ();
  // Progress event list until t=10.
  // Note that AbstractSimTimer does not support t=-\infty.
  el.runUntil (10.0, true, true);
  myTimer.schedule (5, el);
  el.print ();
  el.run ();
}
\end{lstlisting}
The result of which is:
\begin{lstlisting}[basicstyle=\footnotesize]
SimEventList {X}@{Y}, class=DefaultSimEventList, time=10.0:
  t=15.0, name=_expire, object=null, action={...}.
t=15.0: Timer expired!
\end{lstlisting}

Note that you cannot easily {\em reschedule\/} the timer
  from within the action, because there is no
  access to the \lstinline-SimEventList-,
  and that you cannot schedule the timer
  when the time on the event list is infinite
  (hence the \lstinline|runUntil| in the example!).

\section{Summary and Conclusions}

This chapter introduced \lstinline|jsimulation|,
  a small Java library for discrete-event simulation.
An overview of the main interfaces and classes is given below:

\noindent
\begin{tabular}{|l|l|l|}
  \hline
  {\bf Interface} & {\bf Class} & {\bf Description} \\
  \hline
  \lstinline[basicstyle=\footnotesize]|SimEvent<T>|     & & Event \\
                              & \lstinline[basicstyle=\footnotesize]|DefaultSimEvent<T>| & Default Event \\
  \hline
  \lstinline[basicstyle=\footnotesize]|SimEventList<E>| & & \\
                              & \lstinline[basicstyle=\footnotesize]|AbstractSimEventList<E>|     & Event List (partial) \\
                              & \lstinline[basicstyle=\footnotesize]|DefaultSimEventList_ROEL<E>| & Random-Order Event List \\
                              & \lstinline[basicstyle=\footnotesize]|DefaultSimEventList_IOEL<E>| & Insertion-Order Event List \\
                              & \lstinline[basicstyle=\footnotesize]|DefaultSimEventList<E>|      & Default Event List \\
  \hline
  \lstinline[basicstyle=\footnotesize]|SimEventAction<T>| & & Action \\
  \hline
  \lstinline[basicstyle=\footnotesize]|SimEventListResetListener| & & Reset Listener \\
  \lstinline[basicstyle=\footnotesize]|SimEventListListener|      & & Normal Listener \\
  \lstinline[basicstyle=\footnotesize]|SimEventListResetListener| & & Detailed Listener \\
  \hline
  \lstinline[basicstyle=\footnotesize]|SimEventFactory<E>|     & & Event Factory \\
                              & \lstinline[basicstyle=\footnotesize]|DefaultSimEventFactory| & Default Event Factory \\
  \hline
\end{tabular}

The remainder of this book is about \lstinline|jqueues|,
  a library for discrete-event simulation of queueing systems.
The \lstinline|jqueues| library depends on \lstinline|jsimulation|
  for scheduling and processing events and actions.

\chapter{Queueing Systems; Entities, Queues, and Jobs}

This chapter introduces the concepts behind and implementation of the
  \lstinline|jqueues| package.
Together with the underlying \lstinline|jsimulation| package,
  this package allows for discrete-event simulation of
  a very broad range of queueing systems.

\section{Introduction and Definitions}

Despite the fact that we deal with queueing, waiting, being served (or not),
  and being denied service on a daily basis,
  it is,
  unfortunately,
  not that easy at all to precisely define a system
  that captures these "facts of life".
In our, admittedly unsatisfactory, definition,
  a {\em queue\/} or {\em queueing system\/} is an entity
  that can be visited
  by other entities called {\em jobs};
  each visit being initiated by a so-called {\em arrival\/} of a specific job
  at that queue.
A job can only visit only a single queue at a time,
  yet it can hop to another (or the same) queue
  once its visit to a particular queue has ended.
A queue, on the other hand,
  can be visited by multiple jobs.

In {\em queueing theory},
  a branch of mathematics,
  one attempts to predict the behavior of queues and jobs
  without being (too) concerned about the particular {\em reasons\/} of a job visit.
A very common setting is that jobs visit a queue in order to
  get a particular {\em service\/}
  from that queue
  taking a non-trivial amount of time to complete,
  the {\em required service time\/}
  associated with the visit.
In other words,
  visiting jobs have to {\em wait\/} for the completion of their service request.
Even worse,
  the queue is often limited in providing the required services
  to multiple jobs simultaneously,
  so jobs have to {\em compete\/}
  for the {\em service capacity} of the server.
The outcome of this competition is determined by the so-called
  {\em service discipline\/} or {\em queue discipline\/}
  of the queueing system:
  the way in which it distributes its limited (finite)
  service {\em capacity\/} among its currently visiting jobs.

Unfortunately,
  the view of a queueing system as consisting of a waiting area
  in which jobs wait before being served by one or more servers
  (i.e., a finite number of them)
  for a given required service time is too narrow in many
  interesting applications.
For instance, in Medium-Access Control systems,
  the required "service" to waiting jobs
  (i.e., {\em frames to be transmitted\/})
  is largely determined by external events,
  viz.,
  the availability of the {\em medium\/} for transmissions.
In such cases, jobs are not staying in the queue because of an
  {\em intrincic\/} requirement of service from that queue,
  but merely because they are waiting for an event {\em external\/}
  to that queue.
In other words, the notion of "servers" in a queueing system
  providing "service" works for many cases, but not for all.
And from (theoretical) examples like the Processor-Sharing\footnote{
In Processor-Sharing (PS),
  a server equally distributes its service capacity
  among jobs present, see {\bf XXX}.}
  queueing discipline,
  it is clear that the notion of servers serving
  at any time a single job exclusively,
  needs refinement as well.
So, a single server is not constrained,
  in the general case,
  to serving only a single job.
In Infinite-Server (IS), on the other hand,
  each job present is served by its own server
  (of which there are infinitely many),
  meaning that the "total service capacity"
  is not a fixed constant, let alone be known in advance.
The capacity may not even be finite.

In our conceptual model of a queueing system,
  we include explicitly the notions of waiting and of being served,
  but we do not impose {\em any\/} structure on the service.
In our implementation, queues and jobs are
  named \lstinline-SimQueue-s and \lstinline-SimJob-s, respectively.
Their common features are implemented in an abstract base class
  \lstinline-SimEntity-; for simulation entity.

\section{The \lstinline|SimEntity| Interface}

A \lstinline-SimEntity-
  is an entity relevant to event-list scheduling in a queueing system simulation.
Presently, it is either a queue (\lstinline-SimQueue-) or a job (\lstinline-SimJob-).
A queue is an object capable of holding {\em visiting\/} jobs,
  providing (generic) service to these jobs,
  and deciding when (or if) they will leave the queue,
  and end the visit.
A \lstinline-SimEntity- is the common part of queues and jobs.
What they share in common is the event list (\lstinline-SimEventList-) they are attached to,
  the fact that they have a name,
  and their obligation to propagate
  state changes
    (including the currently visited queue of a job,
    and the jobs currently visiting a queue)
  to registered {\em listeners}.
In addition,
  they must notify such listeners of a reset of the event list.
In the table below, we summarize the \lstinline-SimEntity- methods.

\begin{tabular}{|l|l|}
  \hline
  {\bf Method} & {\bf Description} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!SimEventList getEventList ()!
    & Gets the non-\lstinline|null| event list.
    \\ \hline
  \lstinline[basicstyle=\footnotesize]!void registerSimEntityListener!
    & Adds a listener.
    \\
  \lstinline[basicstyle=\footnotesize]!(SimEntityListener<J, Q> listener)!
    & \\ \hline
  \lstinline[basicstyle=\footnotesize]!void unregisterSimEntityListener!
    & Removes a listener.
    \\
  \lstinline[basicstyle=\footnotesize]!(SimEntityListener<J, Q> listener)!
    & \\ \hline
  \lstinline[basicstyle=\footnotesize]!Set<SimEntityListener<J, Q>>!
    & Gets a set of current listeners.
    \\
  \lstinline[basicstyle=\footnotesize]!getSimEntityListeners ()!
    & \\ \hline
  \lstinline[basicstyle=\footnotesize]!String toStringDefault ()!
    & Returns a default, \\
    & type-specific name of the entity. \\ \hline
  \lstinline[basicstyle=\footnotesize]!setName (String name)!
    & Sets the name of the entity. \\ \hline
  \lstinline[basicstyle=\footnotesize]!void resetEntity ()!
    & Puts the entity in its known initial state. \\
  \hline
\end{tabular}

\section{The \lstinline|SimQueue| Interface}

\subsection{Structure of a \lstinline|SimQueue|}

A \lstinline|SimQueue| consists of two areas,
  and while a \lstinline|SimJob| visits a queue,
  it is present in either one of them:
\begin{itemize}
\item The {\em waiting area\/}: After a successful arrival at the queue,
        the visiting job always enters the waiting area;
        in the waiting area, jobs wait before they can be "served",
        or until they leave the queue otherwise.
\item The {\em service area\/}: In the service area,
        jobs receive some sort of (otherwise irrelevant) service from the queue.
      A job can only enter the service area {\em from the waiting area\/};
        it cannot directly enter the service area.
\end{itemize}

\begin{tabular}{|l|l|}
  \hline
  {\bf Method} & {\bf Description} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!Set<J>!
    & The current visitor jobs.
    \\
  \lstinline[basicstyle=\footnotesize]!getJobs ()!
    &
    \\ \hline
  \lstinline[basicstyle=\footnotesize]!int!
    & The number of current visitor jobs.
    \\
  \lstinline[basicstyle=\footnotesize]!getNumberOfJobs ()!
    &
    \\ \hline
  \lstinline[basicstyle=\footnotesize]!Set<J>!
    & The current visitor jobs in the waiting area.
    \\
  \lstinline[basicstyle=\footnotesize]!getJobsInWaitingArea ()!
    &
    \\ \hline
  \lstinline[basicstyle=\footnotesize]!int!
    & The number of current visitor jobs in the waiting area.
    \\
  \lstinline[basicstyle=\footnotesize]!getNumberOfJobsInWaitingArea ()!
    &
    \\ \hline
  \lstinline[basicstyle=\footnotesize]!Set<J>!
    & The current visitor jobs in the service area.
    \\
  \lstinline[basicstyle=\footnotesize]!getJobsInServiceArea ()!
    &
    \\ \hline
  \lstinline[basicstyle=\footnotesize]!int!
    & The number of current visitor jobs in the service area.
    \\
  \lstinline[basicstyle=\footnotesize]!getNumberOfJobsInServiceArea ()!
    &
    \\ \hline
\end{tabular}

\subsection{The \lstinline|SimQueue|-Visit Lifecycle}

\subsubsection{Job Arrival}

A queue visit starts with the arrival of a job
  through \lstinline|arrive(double, J)|.
The first argument of \lstinline|arrive| is the arrival time;
  typically an arrival is scheduled as the result of
  processing a \lstinline|SimEvent| on the event list,
  and the time argument is taken from the event.
The second argument is the \lstinline|SimJob| that arrives;
  note the use of the generic type \lstinline|J|
  restricting the type of jobs (at compile time)
  allowed at the \lstinline|SimQueue|.

\begin{tabular}{|l|l|}
  \hline
  {\bf Method} & {\bf Description} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void!
    & Arrival of a job at the queue.
    \\
  \lstinline[basicstyle=\footnotesize]!arrive (double, J)!
    &
    \\ \hline
\end{tabular}

\subsubsection{Job Drop}

At the discretion of the \lstinline-SimQueue-,
  a job can be forced to leave the queue;
  this is referred to as a {\em job drop}.
Implementations of the \lstinline-SimQueue- interface must
  specify under which conditions they decide to drop jobs.
Typical examples are the unavailability of buffer space,
  or exceeding a maximum allowed service time.
Note that job drops cannot be requested by the user of the queue.
A job can be dropped
  from the waiting area
  as well as
  from the service area.
(For completeness, we note that a job
  can also be dropped immediately upon arrival due
  to queue-access vacations; see next section.)

\subsubsection{Queue-Access Vacation}
\label{queue-access-vacation}

During a queue-access vacation,
  access to the \lstinline|SimQueue| is prohibited
  and all jobs are dropped immediately upon arrival.
A queue-access vacation affects the queue's behavior only upon arrivals;
  it has no effects whatsoever on jobs that are already present
  at the queue.
Note that formally, a job arrival at a queue
  with queue-access vacation
  is {\em not\/} a visit,
  because the job is never actually present at the queue.

\begin{tabular}{|l|l|}
  \hline
  {\bf Method} & {\bf Description} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void!
    & Starts or stops a QAV at given time.
    \\
  \lstinline[basicstyle=\footnotesize]!setQueueAccessVacation (double, boolean)!
    &
    \\ \hline
  \lstinline[basicstyle=\footnotesize]!boolean!
    & Checks for an ongoing QAV.
    \\
  \lstinline[basicstyle=\footnotesize]!isQueueAccessVacation ()!
    &
    \\ \hline
\end{tabular}

\subsubsection{Job Start}

At the discretion of the \lstinline-SimQueue-,
  a visiting \lstinline-SimJob- can be moved from
  the waiting area to the service area.
This is referred to as a {\em job start}.
The start of a job cannot be (directly) controlled by the user.
In our interface, it is important to note that 'started jobs'
  do not necessarily have exclusive access to the server(s).
Between arrival and start, a job is said to be {\em waiting}.
After its start, a job is said to be {\em started}.

\subsubsection{Job Revocation}

Once a job has been offered,
  \lstinline|revoke(double, J, boolean)|
  tries to revoke the job,
  if (still) possible
  and if supported by the queue discipline at all.
The return value indicates if the revocation succeeded.
The first argument is the time of the revocation attempt,
  the second is the job to be revoked.
The third argument indicates whether it is allowed to
  revoke the job from the service area.
If \lstinline|false|, the revocation attempt will always fail
  if the job is already in the service area.
Note the difference between
  a revocation (at the caller's discretion)
  and a drop (at the queue's discretion).

\begin{tabular}{|l|l|}
  \hline
  {\bf Method} & {\bf Description} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!boolean!
    & Revocation attempt of a job at the queue.
    \\
  \lstinline[basicstyle=\footnotesize]!revoke (double, J, boolean)!
    &
    \\ \hline
\end{tabular}

\subsubsection{Server-Access Credits}

During a {\em server-access vacation},
  jobs are prohibited to start,
  i.e.,
  there is no access to the service area for jobs in the waiting area.
It does not affect jobs that have already started.
Server-access vacations are actually
  somewhat more flexible through the notion of {\em server-access credits},
  denoting the number of jobs still admissible to the service area,
  see \lstinline|getServerAccessCredits()|.
A server-access vacation starts
  when there are no more server-access credits (due to jobs starting),
  and ends when credits are explicitly granted to the interface through
  \lstinline|setServerAccessCredits(double, int)|.
Note that by default, each \lstinline|SimQueue| has infinite server-access credits.

\begin{tabular}{|l|l|}
  \hline
  {\bf Method} & {\bf Description} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void!
    & Sets the remaining SACs at given time.
    \\
  \lstinline[basicstyle=\footnotesize]!setServerAccessCredits (double, int)!
    &
    \\ \hline
  \lstinline[basicstyle=\footnotesize]!int!
    & Gets the actual SACs.
    \\
  \lstinline[basicstyle=\footnotesize]!getServerAccessCredits ()!
    &
    \\ \hline
\end{tabular}

Note that the value \lstinline-Integer.MAX_VALUE- is interpreted as $+\infty$.

\subsubsection{Job Departure}

At the discretion of the \lstinline|SimQueue|,
  a visiting job may leave the queue
  because it "got what it came for",
  i.e.,
  its visit comes to an end
  according to the queueing discpline in place.
This is referred to a {\em job departure\/};
  and it cannot be enforced by the user.
We want to stress that jobs do not necessarily
  depart from the service area,
  but can depart from the waiting area as well,
  or even immediately upon arrival
  (in which case we formally do not speak of a visit).

\subsubsection{The \lstinline|NoWaitArmed| Property of a \lstinline|SimQueue|}

\subsubsection{Copying a \lstinline|SimQueue|}

\section{The \lstinline|SimJob| Interface}

Compared to the \lstinline|SimQueue| interface,
  the \lstinline|SimJob| interface is remarkably simple.
Apart from the internal maintenace of the \lstinline-SimQueue-
  being visited,
  a \lstinline-SimJob- only needs to provide information on the
  so-called {\em requested service time\/} for a queue visit,
  through implementation of
  \lstinline-getServiceTime (Q)-.
This method is used by a {@link SimQueue} to query the requested service time,
  and appropriately schedule a departure event for the job,
  but it can be called anytime.
However, the returned value should not change during a visit to a \lstinline-SimQueue-,
  and it is not manipulated by the queue being visited, in other words,
  it cannot be used to query the remaining service time of a job at a queue.
It is safe though to change the return value in-between queue visits.
However, the convention is
  that the method then returns the required service time at the {\em next} visit to
  the queue.
For instance, many test and job-factory classes depend on this, as they often directly probe a non-visiting job for
its required service time at a queue.
Obviously, implementations must be prepared for invocations of this method while not visiting a queue.
If \lstinline|null|,s passed as agrument
  the service time at the current queue is used,
  or zero if the job is not currently visiting a queue.

\begin{tabular}{|l|l|}
  \hline
  {\bf Method} & {\bf Description} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!Q!
    & The queue currently visiting.
    \\
  \lstinline[basicstyle=\footnotesize]!getQueue ()!
    &
    \\ \hline
  \lstinline[basicstyle=\footnotesize]!void!
    & Sets the queue currently visiting.
    \\
  \lstinline[basicstyle=\footnotesize]!setQueue (Q)!
    &
    \\ \hline
  \lstinline[basicstyle=\footnotesize]!double!
    & Gets the service time for a visit.
    \\
  \lstinline[basicstyle=\footnotesize]!getServiceTime (Q)!
    &
    \\ \hline
\end{tabular}

\section{Invariants and Constraints}

Despite the large number of freedom degrees for \lstinline-SimQueue-s,
  there is also a number of (obvious) restrictions on the behavior of a queue.
For instance,
\begin{itemize}
  \item a job cannot start, be dropped or be revoked before having arrived;
  \item a job can start at most once during a queue visit;
  \item a job can only leave the queueing system through departure (with or without being served),
        successful revocation or drop; 
  \item a job may not leave the queue at all (a {\em sticky\/} job).
\end{itemize}
Note that with the current interface, a \lstinline|SimJob| cannot visit multiple SimQueues simultaneously.
The \lstinline|SimQueue| currently being visited by a \lstinline|SimJob|
  can be obtained from \lstinline|SimJob.getQueue ()|;
  this must be maintained by implementations of \lstinline|arrive (J, double)|.

\section{Listening to a \lstinline|SimEntity|}

One can listen to relevant events at a \lstinline|SimEntity| by registering with the entity
  as a \lstinline|SimEntityListener|, the methods of which are summarized in the table below.

\begin{tabular}{|l|l|}
  \hline
  {\bf Method} & {\bf Description} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void notifyResetEntity!
  & Notification of the reset of an entity
  \\
  \lstinline[basicstyle=\footnotesize]!(SimEntity)!
  &
  \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void notifyUpdate!
  & Notification of an update at an entity
  \\
  \lstinline[basicstyle=\footnotesize]!(double, SimEntity)!
  &
  \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void notifyStateChanged!
  & Notification of a state change at an entity
  \\
  \lstinline[basicstyle=\footnotesize]!(double, SimEntity)!
  &
  \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void notifyArrival!
  & Notification of the arrival
  \\
  \lstinline[basicstyle=\footnotesize]!(double, J, Q)!
  & of a job at a queue
  \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void notifyStart!
  & Notification of the start
  \\
  \lstinline[basicstyle=\footnotesize]!(double, J, Q)!
  & of a job at a queue
  \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void notifyDrop!
  & Notification of the drop
  \\
  \lstinline[basicstyle=\footnotesize]!(double, J, Q)!
  & of a job at a queue
  \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void notifyRevocation!
  & Notification of the successful revocation
  \\
  \lstinline[basicstyle=\footnotesize]!(double, J, Q)!
  & of a job at a queue
  \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void notifyDeparture!
  & Notification of the departure
  \\
  \lstinline[basicstyle=\footnotesize]!(double, J, Q)!
  & of a job at a queue
  \\
  \hline
\end{tabular}

It is important to realize that most notifications are fired
  at the time the \lstinline|SimEntity| has processed the
 corresponding event, and attained its new state.
However, there are the following exceptions:
\begin{itemize}
\item Update notifications are, by their nature, fired {\em before\/} any state change;
\item Arrival notifications are fired {\em before\/} the job enters the queue (or before it is dropped);
\item Unsuccessful revocations are {\em not\/} reported as notification.
\end{itemize}

Notifications can have tricky semantics, and one should be careful
  at making assumptions of the \lstinline|SimEntity|
  upon receiving a notification.
This is because with notifications, we attempt to achieve two potentially conflicting objectives:
\begin{itemize}
\item Each state change is reported as notification;
\item Notification listeners always find the \lstinline|SimEntity| in a valid state.
\end{itemize}
So, for instance, one should not assume that during an arrival notification,
  the job is actually present at the queue,
  because a queue-access vacation may be active.
In that case,
  the queue will report an arrival of the job,
  immediately followed by a notification of the job having been dropped.
However, upon reception of the arrival notification,
  the job will not be present at the \lstinline|SimQueue|,
  because that would exhibit an illegal state of that queue.
What we would actually like here,
  is a notification of a {\em sequence\/} of events at the
  queue, all happening at the same time,
  yet in a particular order.
In this particular example, a notification of the sequence
  \lstinline|(ARRIVAL(t,j,q), DROP(t,j,q))|
  would be required,
  where \lstinline|t| is the time,
  \lstinline|j| is the job
  and \lstinline|q| is the queue.
And even though this may not seem important right now,
  realize that certain queue types depend on maintaining the validity
  of invariants throughout their lifetime.
For instance, the \lstinline|DROP| queue drops jobs immediately upon arrival,
  irrespective of the state of the queue-access vacation.
An important sensible invariant for the \lstinline|DROP| queue,
  is that the set of jobs visiting it {\em is always empty}.
Analogeous invariants exist for other queue types,
  and we take great care to enforce these invariants
  to listeners as well as to independently scheduled events.

For \lstinline|SimQueue|s, one can ontain additional information by registering as
  a \lstinline|SimQueueListener|, the methods of which are summarized in the table below.

\begin{tabular}{|l|l|}
  \hline
  {\bf Method} & {\bf Description} \\
  \hline
  \lstinline[basicstyle=\footnotesize]!void notifyNewNoWaitArmed!
  & Notification of a change 
  \\
  \lstinline[basicstyle=\footnotesize]!(double, Q, boolean)!
  & of the \lstinline|noWaitArmed| state
  \\
  \hline
  \lstinline[basicstyle=\footnotesize]|void notifyStartQueueAccessVacation|
  & Notification of the start
  \\
  \lstinline[basicstyle=\footnotesize]|(double, Q)|
  & of a queue-access vacation
  \\
  \hline
  \lstinline[basicstyle=\footnotesize]|void notifyStopQueueAccessVacation|
  & Notification of the end
  \\
  \lstinline[basicstyle=\footnotesize]|(double, Q)|
  & of a queue-access vacation
  \\
  \hline
  \lstinline[basicstyle=\footnotesize]|void notifyOutOfServerAccessCredits|
  & Notification that a queue
  \\
  \lstinline[basicstyle=\footnotesize]|(double, Q)|
  & has run out of server-access credits
  \\
  \hline
  \lstinline[basicstyle=\footnotesize]|void notifyRegainedServerAccessCredits|
  & Notification that a queue
  \\
  \lstinline[basicstyle=\footnotesize]|(double, Q)|
  & has regained server-access credits
  \\
  \hline
\end{tabular}

\chapter{Fundamental Queues}

In this chapter we describe implementations of \lstinline|SimQueue| corresponding
  to well-knwon queueing disciplines.

\section{Introduction}

\section{Serverless Queues}

The {\em serverless\/} queueing systems in \lstinline|jqueues| 
  have no servers and (effectively) no service area.
All state operations and state changes concentrate
  at the waiting area of the queue,
  and typically upon arrivals.
Note that just because the serverless queues have no service area
  does not mean that visiting jobs cannot depart from it.

\subsection{The \lstinline{DROP} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{DROP}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Drops jobs immediately upon arrival.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & QAVs have no effect. \\
\hline
NoWaitArmed & \lstinline|true| & Since jobs are immediately dropped. \\
\hline
Waiting Area & Absent & There is no waiting area. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & SACs have no effect. \\
\hline
Service Area & Absent & There is no service area. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Has no effect. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
        &     & (But jobs are dropped immediately.) \\
\hline
Drop & Yes & All jobs are dropped upon arrival. \\
\hline
Revocation & No & Jobs cannot be revoked \\
           &    & since there are never jobs present. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & SACs have no effect. \\
\hline
Start & No & Jobs cannot start. \\
\hline
Departure & No & Jobs cannot depart. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{The set of jobs present is empty.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList| & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|      & \multicolumn{2}{|l|}{The name, default "DROP"; non-\lstinline|null|; RW.} \\
\hline
\end{tabular}

\subsection{The \lstinline{SINK} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{SINK}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Lets jobs wait indefinitely.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & \lstinline|false| & Since non-dropped jobs must wait. \\
\hline
Waiting Area & Present & Infinite waiting area, non-ordered. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & SACs have no effect. \\
\hline
Service Area & Absent & There is no service area. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
\hline
Drop & Yes & Drops arriving jobs during QAVs. \\
\hline
Revocation & Yes & Jobs can be revoked from the waiting area. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & SACs have no effect. \\
\hline
Start & No & Jobs cannot start. \\
\hline
Departure & No & Jobs cannot depart. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{The set of jobs present in the service area is empty.} \\
\multicolumn{3}{|l|}{All jobs present are in the waiting area.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList| & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|      & \multicolumn{2}{|l|}{The name, default "SINK"; non-\lstinline|null|; RW.} \\
\hline
\end{tabular}

\subsection{The \lstinline{ZERO} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{ZERO}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Lets jobs depart immediately upon arrival.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & \lstinline|true| & Since non-dropped jobs depart immediately. \\
\hline
Waiting Area & Absent & There is no waiting area. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & SACs have no effect. \\
\hline
Service Area & Absent & There is no service area. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
        &     & (But jobs depart immediately.) \\
\hline
Drop & Yes & Drops arriving jobs during QAVs. \\
\hline
Revocation & No & Jobs cannot be revoked \\
           &    & since there are never jobs present. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & SACs have no effect. \\
\hline
Start & No & Jobs cannot start. \\
\hline
Departure & Yes & Non-dropped jobs depart upon arrival. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{The set of jobs present is empty.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList| & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|      & \multicolumn{2}{|l|}{The name, default "ZERO"; non-\lstinline|null|; RW.} \\
\hline
\end{tabular}

\subsection{The \lstinline{DELAY} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{DELAY}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Lets jobs depart after a fixed wait time.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & WaitTime & Since non-dropped jobs depart immediately \\
            & == 0     & when the wait time is zero. \\
\hline
Waiting Area & Present & Infinite waiting area, non-ordered. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & SACs have no effect. \\
\hline
Service Area & Absent & There is no service area. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
        &     & (Immediate departure if WaitTime == 0.) \\
\hline
Drop & Yes & Drops arriving jobs during QAVs. \\
\hline
Revocation & Yes & Jobs can be revoked while waiting. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & SACs have no effect. \\
\hline
Start & No & Jobs cannot start. \\
\hline
Departure & Yes & Non-dropped/revoked jobs depart \\
          &     & WaitTime after arrival. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{The set of jobs present in the service area is empty.} \\
\multicolumn{3}{|l|}{All jobs present are in the waiting area.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList| & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|      & \multicolumn{2}{|l|}{The name, default "DELAY[\lstinline|WaitTime|]";
                                             non-\lstinline|null|; RW.} \\
\hline
\lstinline|WaitTime|  & \multicolumn{2}{|l|}{The wait time, zero or positive; RO.} \\
\hline
\end{tabular}

\subsection{The \lstinline{GATE} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{GATE}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Depending on the state of its "gate", let jobs} \\
            & \multicolumn{2}{|l|}{depart immediately or puts them into the waiting area.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & GPC $> 0$ & Since non-dropped jobs depart immediately upon arrival \\
            &           & provided that there are gate-passage credits (GPCs). \\
\hline
Waiting Area & Present & Infinite waiting area, arrival order. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & SACs have no effect. \\
\hline
Service Area & Absent & There is no service area. \\
\hline
GPC & $\{0, 1, 2, \ldots\}$ & Number of jobs to depart immediately upon arrival. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
\hline
Drop & Yes & Drops arriving jobs during QAVs. \\
\hline
Revocation & Yes & Jobs can be revoked while waiting. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & SACs have no effect. \\
\hline
Start & No & Jobs cannot start. \\
\hline
Departure & Yes & Non-dropped/revoked jobs depart upon arrival \\
          &     & or if (sufficient) GPCs become available. \\
\hline
Set GPC & $\{0, 1, 2, \ldots\}$ & Overwrites the remaining number of GPCs. \\
        &                       & (Letting jobs depart if waiting and GPC $ > 0$). \\
        &                       & \lstinline|Integer.MAX_VALUE| is treated as $+\infty$. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{The set of jobs present in the service area is empty.} \\
\multicolumn{3}{|l|}{All jobs present are in the waiting area.} \\
\multicolumn{3}{|l|}{If GPC $> 0$, the set of jobs present is empty.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList| & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|      & \multicolumn{2}{|l|}{The name, default "GATE"; non-\lstinline|null|; RW.} \\
\hline
\end{tabular}

\section{Nonpreemptive Queues}

\subsection{The \lstinline{FCFS} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{FCFS}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Serves jobs in arrival order with a single server.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & No Jobs & Since non-dropped arriving jobs are taken into \\
            &         & service immediately if no other jobs are present. \\
\hline
Waiting Area & Present & Infinite waiting area, arrival order. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & The remaining number of jobs that can start. \\
    &                       & \lstinline|Integer.MAX_VALUE| is treated as $+\infty$. \\
\hline
Service Area & Present & Holds the job currently in service (if any). \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
\hline
Drop & Yes & Drops arriving jobs during QAVs. \\
\hline
Revocation & Yes & Jobs can be revoked while waiting and while being served. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & Sets/overwrites SAC; \lstinline|Integer.MAX_VALUE| $== +\infty$. \\
        &                       & Starts waiting job if SAC $> 0$ and server idle. \\
\hline
Start & Yes & Starts jobs if there are SACs and the server is idle. \\
\hline
Departure & Yes & Started and non-revoked jobs depart. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{At most one job is present in the service area.} \\
\multicolumn{3}{|l|}{If SAC $> 0$, the server cannot be idle in the presence of waiting jobs.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList|       & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|            & \multicolumn{2}{|l|}{The name, default "FCFS"; non-\lstinline|null|; RW.} \\
\hline
\lstinline|NumberOfServers| & \multicolumn{2}{|l|}{The number of servers; always $1$; RO.} \\
\hline
\end{tabular}

\subsection{The \lstinline{FCFS_B} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{FCFS_B}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Serves jobs in arrival order with a single server} \\
            & \multicolumn{2}{|l|}{but has limited capacity for waing jobs.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & No Jobs & Since arriving jobs are dropped or taken into \\
            &         & service immediately if no other jobs are present. \\
\hline
Waiting Area & Present & Finite waiting area of size \lstinline|BufferSize|, arrival order. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & The remaining number of jobs that can start. \\
    &                       & \lstinline|Integer.MAX_VALUE| is treated as $+\infty$. \\
\hline
Service Area & Present & Holds the job currently in service (if any). \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
\hline
Drop & Yes & Drops arriving jobs during QAVs \\
     &     & and while there are \lstinline|BufferSize| waiting jobs. \\
\hline
Revocation & Yes & Jobs can be revoked while waiting and while being served. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & Sets/overwrites SAC; \lstinline|Integer.MAX_VALUE| $== +\infty$. \\
        &                       & Starts waiting job if SAC $> 0$ and server idle. \\
\hline
Start & Yes & Starts jobs if there are SACs and the server is idle. \\
\hline
Departure & Yes & Started and non-revoked jobs depart. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{At most one job is present in the service area.} \\
\multicolumn{3}{|l|}{At most \lstinline|BufferSize| jobs are present in the waiting area.} \\
\multicolumn{3}{|l|}{If SAC $> 0$, the server cannot be idle in the presence of waiting jobs.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList|       & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|            & \multicolumn{2}{|l|}{The name, default "FCFS\_B[\lstinline|BufferSize|]";
                                                   non-\lstinline|null|; RW.} \\
\hline
\lstinline|NumberOfServers| & \multicolumn{2}{|l|}{The number of servers; always $1$; RO.} \\
\hline
\lstinline|BufferSize|      & \multicolumn{2}{|l|}{The buffer size; non-negative; RO.} \\
                            & \multicolumn{2}{|l|}{\lstinline|Integer.MAX_VALUE| is treated as $+\infty$.} \\
\hline
\end{tabular}

\subsection{The \lstinline{FCFS_c} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{FCFS_c}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Serves jobs in arrival order with multiple ($c$) servers.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & \lstinline|NumberOfJobs| & Since non-dropped arriving jobs are taken into \\
            & $< c$                    & service immediately if at least one server is idle. \\
\hline
Waiting Area & Present & Infinite waiting area, arrival order. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & The remaining number of jobs that can start. \\
    &                       & \lstinline|Integer.MAX_VALUE| is treated as $+\infty$. \\
\hline
Service Area & Present & Holds the jobs (upto $c$) currently in service (if any). \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
\hline
Drop & Yes & Drops arriving jobs during QAVs. \\
\hline
Revocation & Yes & Jobs can be revoked while waiting and while being served. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & Sets/overwrites SAC; \lstinline|Integer.MAX_VALUE| $== +\infty$. \\
        &                       & Starts waiting job(s) if SAC $> 0$ and it least one server is idle. \\
\hline
Start & Yes & Starts jobs if there are SACs and at least one server is idle. \\
\hline
Departure & Yes & Started and non-revoked jobs depart. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{At most $c$ jobs are present in the service area.} \\
\multicolumn{3}{|l|}{If SAC $> 0$, a server cannot be idle in the presence of waiting jobs.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList|       & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|            & \multicolumn{2}{|l|}{The name, default "FCFS\_\lstinline{NumberOfServers}";
                                                   non-\lstinline|null|; RW.} \\
\hline
\lstinline|NumberOfServers| & \multicolumn{2}{|l|}{The number $c$ of servers; non-negative; RO.} \\
                            & \multicolumn{2}{|l|}{\lstinline|Integer.MAX_VALUE| is treated as $+\infty$.} \\
\hline
\end{tabular}

\subsection{The \lstinline{IS} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{IS}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Serves jobs in arrival order with an infinite number of servers.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & \lstinline|true| & Since non-dropped arriving jobs \\
            &                  & are taken into service immediately. \\
\hline
Waiting Area & Present & Infinite waiting area, arrival order. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & The remaining number of jobs that can start. \\
    &                       & \lstinline|Integer.MAX_VALUE| is treated as $+\infty$. \\
\hline
Service Area & Present & Holds the jobs currently in service (if any). \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
\hline
Drop & Yes & Drops arriving jobs during QAVs. \\
\hline
Revocation & Yes & Jobs can be revoked while waiting and while being served. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & Sets/overwrites SAC; \lstinline|Integer.MAX_VALUE| $== +\infty$. \\
        &                       & Starts waiting jobs in arrival order while SAC $> 0$. \\
\hline
Start & Yes & Starts jobs if there are SACs. \\
\hline
Departure & Yes & Started and non-revoked jobs depart. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{If SAC $> 0$, there are no jobs in the waiting area.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList|       & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|            & \multicolumn{2}{|l|}{The name, default "IS"; non-\lstinline|null|; RW.} \\
\hline
\end{tabular}

\subsection{The \lstinline{IS_CST} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{IS_CST}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Serves jobs in arrival order with an infinite number of servers.} \\
            & \multicolumn{2}{|l|}{Each job is served for a queue-determined fixed service time.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & \lstinline|true| & Since non-dropped arriving jobs \\
            &                  & are taken into service immediately. \\
\hline
Waiting Area & Present & Infinite waiting area, arrival order. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & The remaining number of jobs that can start. \\
    &                       & \lstinline|Integer.MAX_VALUE| is treated as $+\infty$. \\
\hline
Service Area & Present & Holds the jobs currently in service (if any). \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
\hline
Drop & Yes & Drops arriving jobs during QAVs. \\
\hline
Revocation & Yes & Jobs can be revoked while waiting and while being served. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & Sets/overwrites SAC; \lstinline|Integer.MAX_VALUE| $== +\infty$. \\
        &                       & Starts waiting jobs in arrival order while SAC $> 0$. \\
\hline
Start & Yes & Starts jobs if there are SACs. \\
\hline
Departure & Yes & Started and non-revoked jobs depart. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{If SAC $> 0$, there are no jobs in the waiting area.} \\
\multicolumn{3}{|l|}{If \lstinline|ServiceTime| $== 0$, there are no jobs in the service area.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList|       & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|            & \multicolumn{2}{|l|}{The name, default "IS\_CST[\lstinline|ServiceTime|]";
                                                   non-\lstinline|null|; RW.} \\
\hline
\lstinline|ServiceTime|     & \multicolumn{2}{|l|}{The service time for each job; non-negative; RO.} \\
\hline
\end{tabular}

\subsection{The \lstinline{IC} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{IC}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Serves jobs in arrival order with an infinite number of servers,} \\
            & \multicolumn{2}{|l|}{each of which is of infinite capacity and serves any job in zero time.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & \lstinline|true| & Since non-dropped arriving jobs \\
            &                  & are taken into service immediately. \\
\hline
Waiting Area & Present & Infinite waiting area, arrival order. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & The remaining number of jobs that can start. \\
    &                       & \lstinline|Integer.MAX_VALUE| is treated as $+\infty$. \\
\hline
Service Area & Present & Holds the jobs currently in service (if any). \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
\hline
Drop & Yes & Drops arriving jobs during QAVs. \\
\hline
Revocation & Yes & Jobs can be revoked while waiting for SACs. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & Sets/overwrites SAC; \lstinline|Integer.MAX_VALUE| $== +\infty$. \\
        &                       & Starts waiting jobs in arrival order while SAC $> 0$. \\
\hline
Start & Yes & Starts jobs if there are SACs. \\
\hline
Departure & Yes & Started and non-revoked jobs depart. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{If SAC $> 0$, there are no jobs in the waiting area.} \\
\multicolumn{3}{|l|}{There are no jobs in the service area.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList|       & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|            & \multicolumn{2}{|l|}{The name, default "IC"; non-\lstinline|null|; RW.} \\
\hline
\end{tabular}

\subsection{The \lstinline{LCFS} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{LCFS}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Serves jobs in reverse arrival order with a single server.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & No Jobs & Since non-dropped arriving jobs are taken into \\
            &         & service immediately if no other jobs are present. \\
\hline
Waiting Area & Present & Infinite waiting area, reverse arrival order. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & The remaining number of jobs that can start. \\
    &                       & \lstinline|Integer.MAX_VALUE| is treated as $+\infty$. \\
\hline
Service Area & Present & Holds the job currently in service (if any). \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
\hline
Drop & Yes & Drops arriving jobs during QAVs. \\
\hline
Revocation & Yes & Jobs can be revoked while waiting and while being served. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & Sets/overwrites SAC; \lstinline|Integer.MAX_VALUE| $== +\infty$. \\
        &                       & Starts waiting job if SAC $> 0$ and server idle. \\
\hline
Start & Yes & Starts jobs if there are SACs and the server is idle. \\
\hline
Departure & Yes & Started and non-revoked jobs depart. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{At most one job is present in the service area.} \\
\multicolumn{3}{|l|}{If SAC $> 0$, the server cannot be idle in the presence of waiting jobs.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList|       & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|            & \multicolumn{2}{|l|}{The name, default "LCFS"; non-\lstinline|null|; RW.} \\
\hline
\lstinline|NumberOfServers| & \multicolumn{2}{|l|}{The number of servers; always $1$; RO.} \\
\hline
\end{tabular}

\subsection{The \lstinline{SJF} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{SJF}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Serves jobs in increasing service-time order with a single server.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & No Jobs & Since non-dropped arriving jobs are taken into \\
            &         & service immediately if no other jobs are present. \\
\hline
Waiting Area & Present & Infinite waiting area, ordered increasing in service time. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & The remaining number of jobs that can start. \\
    &                       & \lstinline|Integer.MAX_VALUE| is treated as $+\infty$. \\
\hline
Service Area & Present & Holds the job currently in service (if any). \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
\hline
Drop & Yes & Drops arriving jobs during QAVs. \\
\hline
Revocation & Yes & Jobs can be revoked while waiting and while being served. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & Sets/overwrites SAC; \lstinline|Integer.MAX_VALUE| $== +\infty$. \\
        &                       & Starts waiting job if SAC $> 0$ and server idle. \\
\hline
Start & Yes & Starts jobs if there are SACs and the server is idle. \\
\hline
Departure & Yes & Started and non-revoked jobs depart. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{At most one job is present in the service area.} \\
\multicolumn{3}{|l|}{If SAC $> 0$, the server cannot be idle in the presence of waiting jobs.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList|       & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|            & \multicolumn{2}{|l|}{The name, default "SJF"; non-\lstinline|null|; RW.} \\
\hline
\lstinline|NumberOfServers| & \multicolumn{2}{|l|}{The number of servers; always $1$; RO.} \\
\hline
\end{tabular}

\subsection{The \lstinline{LJF} \lstinline{SimQueue}}
 
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{LJF}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Serves jobs in decreasing service-time order with a single server.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & No Jobs & Since non-dropped arriving jobs are taken into \\
            &         & service immediately if no other jobs are present. \\
\hline
Waiting Area & Present & Infinite waiting area, ordered decreasing in service time. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & The remaining number of jobs that can start. \\
    &                       & \lstinline|Integer.MAX_VALUE| is treated as $+\infty$. \\
\hline
Service Area & Present & Holds the job currently in service (if any). \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
\hline
Drop & Yes & Drops arriving jobs during QAVs. \\
\hline
Revocation & Yes & Jobs can be revoked while waiting and while being served. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & Sets/overwrites SAC; \lstinline|Integer.MAX_VALUE| $== +\infty$. \\
        &                       & Starts waiting job if SAC $> 0$ and server idle. \\
\hline
Start & Yes & Starts jobs if there are SACs and the server is idle. \\
\hline
Departure & Yes & Started and non-revoked jobs depart. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{At most one job is present in the service area.} \\
\multicolumn{3}{|l|}{If SAC $> 0$, the server cannot be idle in the presence of waiting jobs.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList|       & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|            & \multicolumn{2}{|l|}{The name, default "LJF"; non-\lstinline|null|; RW.} \\
\hline
\lstinline|NumberOfServers| & \multicolumn{2}{|l|}{The number of servers; always $1$; RO.} \\
\hline
\end{tabular}

\subsection{The \lstinline{RANDOM} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{RANDOM}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Serves jobs in random order with a single server.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & No Jobs & Since non-dropped arriving jobs are taken into \\
            &         & service immediately if no other jobs are present. \\
\hline
Waiting Area & Present & Infinite waiting area, random order with equal probabilities. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & The remaining number of jobs that can start. \\
    &                       & \lstinline|Integer.MAX_VALUE| is treated as $+\infty$. \\
\hline
Service Area & Present & Holds the job currently in service (if any). \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals. \\
\hline
Drop & Yes & Drops arriving jobs during QAVs. \\
\hline
Revocation & Yes & Jobs can be revoked while waiting and while being served. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & Sets/overwrites SAC; \lstinline|Integer.MAX_VALUE| $== +\infty$. \\
        &                       & Starts waiting job if SAC $> 0$ and server idle. \\
\hline
Start & Yes & Starts jobs if there are SACs and the server is idle. \\
\hline
Departure & Yes & Started and non-revoked jobs depart. \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{At most one job is present in the service area.} \\
\multicolumn{3}{|l|}{If SAC $> 0$, the server cannot be idle in the presence of waiting jobs.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList|       & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|            & \multicolumn{2}{|l|}{The name, default "RANDOM"; non-\lstinline|null|; RW.} \\
\hline
\lstinline|NumberOfServers| & \multicolumn{2}{|l|}{The number of servers; always $1$; RO.} \\
\hline
\end{tabular}

\section{Preemptive Queues}

\subsection{The \lstinline{P_LCFS} \lstinline{SimQueue}}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{P_LCFS}} \\
\multicolumn{3}{|c|}{} \\
\hline
Description & \multicolumn{2}{|l|}{Serves jobs in reverse arrival order with a single server,} \\
            & \multicolumn{2}{|l|}{preempting the current job in service, if any, upon an arrival.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State} \\
\multicolumn{3}{|c|}{} \\
\hline
QAV & \lstinline|false|/\lstinline|true| & Drops arriving jobs during QAVs. \\
\hline
NoWaitArmed & \lstinline|true| & Since non-dropped arriving jobs are taken into \\
            &                  & service immediately. \\
\hline
Waiting Area & Present & Infinite waiting area, reverse arrival order. \\
\hline
SAC & $\{0, 1, 2, \ldots\}$ & The remaining number of jobs that can start. \\
    &                       & \lstinline|Integer.MAX_VALUE| is treated as $+\infty$. \\
\hline
Service Area & Present & Holds the job currently in service (if any), \\
             &         & and all {\em preempted\/} jobs (if any). \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State Operations} \\
\multicolumn{3}{|c|}{} \\
\hline
Set QAV & \lstinline|false|/\lstinline|true| & Ends/starts a QAV. \\
\hline
Arrival & Yes & The queue accepts arrivals, \\
        &     & preempting the job currently in service (if any). \\
\hline
Drop & Yes & Drops arriving jobs during QAVs and preempted jobs \\
     &     & with \lstinline|DROP| preemption strategy. \\
\hline
Revocation & Yes & Jobs can be revoked while waiting, while being served, \\
           &     & and if having been preempted in the service area. \\
\hline
Set SAC & $\{0, 1, 2, \ldots\}$ & Sets/overwrites SAC; \lstinline|Integer.MAX_VALUE| $== +\infty$. \\
        &                       & Starts waiting job if SAC $> 0$ and server idle. \\
\hline
Start & Yes & Starts jobs if there are SACs and the server is idle. \\
\hline
Preemption & Yes & Job in service is preempted upon a new (non-dropped) arrival. \\
\hline
Departure & Yes & Started and non-revoked jobs depart. \\
          &     & Jobs with \lstinline|DROP| preemption strategy only \\
          &     & depart if not preempted after start. \\
\hline
\end{tabular}

\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\lstinline[basicstyle=\large]{P_LCFS} (continued)} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf State  Invariants} \\
\multicolumn{3}{|c|}{} \\
\hline
\multicolumn{3}{|l|}{If SAC $> 0$, the server cannot be idle in the presence of waiting jobs.} \\
\multicolumn{3}{|l|}{The server cannot be idle in the presence of preempted jobs in the service area.} \\
\hline
\multicolumn{3}{|c|}{} \\
\multicolumn{3}{|c|}{\bf Properties} \\
\multicolumn{3}{|c|}{} \\
\hline
\lstinline|EventList|          & \multicolumn{2}{|l|}{The event list; non-\lstinline|null|; RO.} \\
\hline
\lstinline|Name|               & \multicolumn{2}{|l|}{The name, default "P\_LCFS[\lstinline|PreemptionStrategy|]";} \\
                               & \multicolumn{2}{|l|}{non-\lstinline|null|; RW.} \\
\hline
\lstinline|PreemptionStrategy| & \multicolumn{2}{|l|}{The preemption strategy, default \lstinline|RESUME|;
                                                      non-\lstinline|null|; RO.} \\
\hline
\lstinline|NumberOfServers|    & \multicolumn{2}{|l|}{The number of servers; always $1$; RO.} \\
\hline
\end{tabular}

\subsection{The \lstinline{SRTF} \lstinline{SimQueue}}

\section{Processor-Sharing Queues}

\subsection{The \lstinline{PS} \lstinline{SimQueue}}

\subsection{The \lstinline{CATCH-UP-PS} \lstinline{SimQueue}}

\section{Multiclass Queues}

\subsection{The \lstinline{HOL} \lstinline{SimQueue}}

\subsection{The \lstinline{PQ} \lstinline{SimQueue}}

\subsection{The \lstinline{WPS} \lstinline{SimQueue}}

\subsection{The \lstinline{G-WPS} \lstinline{SimQueue}}

\subsection{The \lstinline{HOL-PS} \lstinline{SimQueue}}

\section{\lstinline|SimQueue| Equalities}

\begin{tabular}{|l|l|}
\hline
\lstinline|DELAY[0]| & \lstinline|ZERO| \\
\hline
\lstinline|DELAY[Double.POSITIVE_INFINITY]| & \lstinline|SINK| \\
\hline
\lstinline|FCFS_B[0]| & \lstinline|DROP| \\
\hline
\lstinline|FCFS_B[Integer.MAX_VALUE]| & \lstinline|FCFS| \\
\hline
\lstinline|FCFS_0| & \lstinline|SINK| \\
\hline
\lstinline|FCFS_1| & \lstinline|FCFS| \\
\hline
\lstinline|FCFS_Integer.MAX_VALUE| & \lstinline|IS| \\
\hline
\lstinline|IS_CST[0]| & \lstinline|IC| \\
\hline
\end{tabular}

\chapter{Multiclass Queues and Jobs}

\chapter{Fundamental Multiclass Queues}

\chapter{Composite Queues}

\section{Introduction}

Composite queues consist of zero or more other queues
  named {\em subqueues\/} or {\em embedded queues\/}
  through which visiting jobs must pass.
The sequence of visits to the embedded queues is
  determined by the composite queue.

{\bf XXX}

\section{Types (Colors) of Composite Queues}

\chapter{Fundamental Composite Queues}

\section{Introduction}

\section{Tandem Queues}

\section{Compressed Tandem Queues}

\section{Parallel Queues}

\section{Feedback Queues}

\section{Jackson Networks}

\section{Special Composite Queues}

\subsection{Encapsulator Queues}

\subsection{Drop-Collector Queues}

\chapter{Queue and Job Statistics}

\section{Introduction}

If you have read this book linearly up to this point,
  we hope you are wondering by now how to compute
  statistics like average job sojourn time at a queue,
  or average server utilization (just to name a few).
Actually, this is somewhat on purpose: None of the
  interfaces and concrete implementations
  of jobs and queues
  provide direct support for maintaining and calculating statistics.
This has three important reasons:
\begin{itemize}
\item It relieves the concrete \lstinline|SimQueue|
        and \lstinline|SimJob| implementations of the
        tedious and error-prone responsability of
        maintaining and calculting statistics;
        their basis functionality in terms of
        e.g. implementing the proper queueing discipline is
        complicated enough as it is.
\item It forces the implementation of statistics in a generic way,
      e.g., applicable to {\em any\/} queue type.
\item It allows for easy replacement of {\em all\/} statistics-gathering
        and maintenance code with that of a professional
        third-party statistics package like {\bf XXX}.
\end{itemize}

Needless to say, \lstinline|jqueues| has full support for the implementation of
  statistics, and actually, provides a few basic, but highly effective and extensible
  classes for statistics gathering itself.
The starting point for gathering statistics of a \lstinline|SimEntity|
  is to register as a suitable \lstinline|SimEntityListener| to it,
  and update statistics upon notifications from the entity,
  inparticular update notifications and
  visit-related notifications like arrivals, drops and departures.
Recall that a \lstinline|SimEntity| is required to notify registered listeners
  {\em just before\/} it state changes through an update notification,
  allowing for easy maintenance of "time-average-type" statistics
  like the average number of jobs present at a queue.
In addition (and often requiring a bit more work) the visit-related notifications
  allow for maintenance of "visit-related" statistics,
  like the average job sojourn time at a queue.

In the following section, we will first explain how to obtain statistics
  for a \lstinline|SimQueue| or \lstinline|SimJob| manually,
  following the approach outline above.
Subsequently,
  we will introduce a few statistics-related class
  that intend to make it easier to
  obtain such statistics.

\subsection{Example: The Average Number of Jobs at a Queue}

In this statistics-related example,
  we create a \lstinline|SimQueue| and
  a workload consisting of arriving \lstinline|SimJob|s.
Our objective is to run the simulation,
  and calculate the average number of jobs at the queue.
{\bf XXX}

\subsection{Example: The Total Sojourn of a Job at Visited Queues}

\section{The \lstinline|AbstractSimQueueStat| Base Class}

\section{The \lstinline|SimpleSimQueueStat| Class}

\section{The \lstinline|AutoSimQueueStat| Class}

\subsection{Introduction}

\subsection{The \lstinline|SimQueueProbe| Interface}

\subsection{Example}

\section{The \lstinline|SimpleSimQueueVisitsStat| Class}

\subsection{Introduction}

\subsection{Example}

\chapter{Visualization of Queues and Jobs with Swing Components}

\chapter{Advanced Topics}

\section{Job Factories}

\section{Queue Events and Schedules}

\section{Load Factories}

\chapter{Building Custom Queues and Jobs}

\section{Introduction}

\section{Building Custom Entities}

\subsection{Introduction}

\subsection{The \lstinline{AbstractSimEntity} Class}

\section{Building Custom Queues}

\subsection{Introduction}

\subsection{The \lstinline{AbstractSimQueueBase} Class}

\subsection{The \lstinline{AbstractSimQueue} Class}

\section{Building Custom Jobs}

\subsection{Introduction}

\subsection{The \lstinline{AbstractSimJob} Class}

\subsection{The \lstinline{DefaultSimJob} Class}

\chapter{Other Topics}

\section{Introduction}

\section{Building Custom Listeners}

\chapter{Test Infrastructure}

\section{Introduction}

\section{Test-Infrastructure Overview}

\subsection{Introduction}

\subsection{Queue Workloads}

\subsection{Queue Predictors}

\subsection{Confronting Queue Workloads, Predictors, and Queues}

\section{Workloads}

\subsection{Creating Workloads}

\subsection{Workload Ambiguities}

\subsection{Standardized Workload Patterns}

\subsection{Building a Workload}

\section{Predictors}

\subsection{Using a Predictor}

\subsection{Building a Predictor}

\chapter{Conclusions}

\end{document}
